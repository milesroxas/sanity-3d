/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useMemo, useContext, createContext } from 'react';
import { useGLTF, Merged } from '@react-three/drei';
import type * as THREE from 'three';
import type { GLTF } from 'three-stdlib';
import { ThreeElements } from '@react-three/fiber';
type GLTFResult = GLTF & {
  nodes: {
    ['terrain-mountains']: THREE.Mesh;
    ['terrain-mountains001']: THREE.Mesh;
    ['terrain-mountains002']: THREE.Mesh;
    ['terrain-mountains004']: THREE.Mesh;
    ['terrain-mountains005']: THREE.Mesh;
  };
  materials: {
    ['14 BROWN-LIGHTEST']: THREE.MeshPhysicalMaterial;
  };
};

interface MountainInstances {
  Terrainmountains: React.ComponentType<ThreeElements['mesh']>;
  Terrainmountains001: React.ComponentType<ThreeElements['mesh']>;
  Terrainmountains002: React.ComponentType<ThreeElements['mesh']>;
  Terrainmountains004: React.ComponentType<ThreeElements['mesh']>;
  Terrainmountains005: React.ComponentType<ThreeElements['mesh']>;
}

type MountainPosition = {
  position: [number, number, number];
  rotation?: [number, number, number];
  scale: number | [number, number, number];
};

const MOUNTAIN_POSITIONS: Record<string, MountainPosition[]> = {
  outer: [
    {
      position: [337.45, 0.322, -0.747],
      scale: 5.026,
    },
    {
      position: [68.334, 0.322, -294.717],
      rotation: [Math.PI, 0, Math.PI],
      scale: 5.026,
    },
    {
      position: [-213.718, -1.971, -240.283],
      scale: [5.026, 3.712, 5.026],
    },
    {
      position: [-362.048, 0.322, 21.936],
      scale: 5.026,
    },
  ],
};

const context = createContext<MountainInstances | null>(null);

export function Instances({ children, ...props }: { children: React.ReactNode }) {
  const { nodes } = useGLTF('/models/mountains.glb') as unknown as GLTFResult;
  const instances = useMemo(
    () => ({
      Terrainmountains: nodes['terrain-mountains'],
    }),
    [nodes]
  );
  return (
    <Merged meshes={instances} {...props}>
      {meshes => (
        <context.Provider value={meshes as unknown as MountainInstances}>
          {children}
        </context.Provider>
      )}
    </Merged>
  );
}

function Mountain({ position, rotation = [0, 0, 0], scale }: MountainPosition) {
  const instances = useContext(context);

  if (!instances) {
    console.error('Mountain must be used within an Instances component');
    return null;
  }

  return (
    <group position={position} rotation={rotation} scale={scale}>
      <instances.Terrainmountains name="terrain-mountains" />
    </group>
  );
}

function MountainsContent(props: ThreeElements['group']) {
  const { nodes, materials } = useGLTF('/models/mountains.glb') as unknown as GLTFResult;
  const mountainPositions = useMemo(() => {
    const positions: MountainPosition[] = [];

    // Add all mountain positions from each area
    Object.values(MOUNTAIN_POSITIONS).forEach(group => {
      group.forEach(({ position, rotation, scale }) => {
        positions.push({
          position,
          rotation,
          scale,
        });
      });
    });

    return positions;
  }, []);

  return (
    <group {...props} dispose={null}>
      {mountainPositions.map((mountainProps, index) => (
        <Mountain key={index} {...mountainProps} />
      ))}
      {/* Keep the non-instanced mesh separate */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes['terrain-mountains004'].geometry}
        material={materials['14 BROWN-LIGHTEST']}
        position={[296.382, 0.322, -285.564]}
        scale={[5.026, 3.712, 5.026]}
      />
    </group>
  );
}

export function Mountains(props: ThreeElements['group']) {
  return (
    <Instances>
      <MountainsContent {...props} />
    </Instances>
  );
}

useGLTF.preload('/models/mountains.glb');
