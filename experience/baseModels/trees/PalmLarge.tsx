/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import type * as THREE from "three";
import React, { useMemo, useContext, createContext, useEffect } from "react";
import type { ReactNode } from "react";
import { useGLTF, Merged } from "@react-three/drei";
import type { GLTF } from "three-stdlib";
import { ThreeElements } from "@react-three/fiber";

type GLTFResult = GLTF & {
  nodes: {
    ["palm-high_1"]: THREE.Mesh;
    ["palm-high_2"]: THREE.Mesh;
  };
  materials: {
    ["11 BROWN-MEDIUM.004"]: THREE.MeshPhysicalMaterial;
    ["37 GREEN-LIGHT.001"]: THREE.MeshPhysicalMaterial;
  };
};

type PalmPosition = {
  position: [number, number, number];
  rotation?: [number, number, number];
  scale?: number;
};

interface PalmInstances {
  Palmhigh: React.ComponentType<ThreeElements["mesh"]>;
  Palmhigh1: React.ComponentType<ThreeElements["mesh"]>;
}

const PalmInstancesContext = createContext<PalmInstances | null>(null);

// Define palm tree patterns by area with proper typing
const PALM_POSITIONS: Record<string, PalmPosition[]> = {
  northEastCluster: [
    { position: [67.31, 2.667, 62.459], rotation: [0, 0, 0], scale: 1 },
    {
      position: [72.965, 2.667, 69.209],
      rotation: [0, -0.644, 0],
      scale: 0.906,
    },
    { position: [102.654, 2.667, 69.209], rotation: [0, 0, 0], scale: 0.906 },
  ],
  centralRow: [
    { position: [72.705, 2.667, 80.355], scale: 0.906 },
    { position: [103.781, 2.667, 80.355], scale: 0.906 },
    { position: [119.199, 2.667, 80.355], scale: 0.906 },
    { position: [117.256, 2.667, 68.978], scale: 0.906 },
  ],
  northernRow: [
    {
      position: [116.452, 2.667, 54.406],
      rotation: [Math.PI, 0, Math.PI],
      scale: 0.906,
    },
    {
      position: [86.311, 2.667, 54.406],
      rotation: [Math.PI, 0, Math.PI],
      scale: 0.906,
    },
    {
      position: [101.321, 2.667, 54.406],
      rotation: [Math.PI, 0, Math.PI],
      scale: 0.906,
    },
  ],
  westernArea: [
    { position: [67.652, 2.667, 87.881], scale: 0.875 },
    { position: [39.053, 2.667, 86.249] },
    { position: [39.053, 2.667, 64.162] },
    { position: [39.053, 2.667, 58.977] },
    { position: [39.053, 2.667, 91.698] },
  ],
  southernBorder: [
    { position: [82.331, 2.667, 99.358], scale: 0.906 },
    { position: [60.049, 2.667, 99.358], scale: 0.906 },
    { position: [112.472, 2.667, 99.358], scale: 0.906 },
    { position: [97.462, 2.667, 99.358], scale: 0.906 },
    { position: [128.038, 2.667, 99.358], scale: 0.906 },
  ],
  westernBorder: [
    { position: [-78.808, 2.667, 63.365] },
    { position: [-93.991, 2.667, 63.365] },
    { position: [-84.769, 2.667, 5.817] },
    { position: [-78.808, 2.667, 24.492] },
    { position: [-93.991, 2.667, 24.492] },
    { position: [-69.585, 2.667, 5.817] },
  ],
  outterHomes: [
    { position: [5.853905, 2.666663, 131.784851] },
    { position: [5.853905, 2.666663, 118.173927]},
    { position: [5.174774, 2.666663, 105.850266] },
    { position: [5.903057, 2.666663, 92.140800] },
    { position: [-20.069424, 2.666663, 113.366829] },
    { position: [-20.069424, 2.666663, 97.918686] },
    { position: [-38.547882, 2.666663, 113.366829] },
    { position: [-38.547882, 2.666663, 97.918686] },
  ],

};

interface InstancesProps {
  children: ReactNode;
  /** Any other group props you might want */
  [key: string]: unknown;
}

export function Instances({ children, ...props }: InstancesProps) {
  const { nodes, materials } = useGLTF("/models/tree-large.glb") as GLTFResult;

  // Explicitly set shadow properties on all meshes
  Object.values(nodes).forEach((node: any) => {
    if (node.isMesh) {
      node.castShadow = true;
      node.receiveShadow = true;
      
      // Ensure materials are configured for shadows
      if (node.material) {
        node.material.needsUpdate = true;
      }
    }
  });

  // This is the raw data from the GLTF
  const instanceMeshes = useMemo(
    () => ({
      Palmhigh: nodes["palm-high_1"],
      Palmhigh1: nodes["palm-high_2"],
    }),
    [nodes]
  );

  return (
    <Merged meshes={instanceMeshes} {...props}>
      {(instances: PalmInstances) => (
        <PalmInstancesContext.Provider value={instances}>
          {children}
        </PalmInstancesContext.Provider>
      )}
    </Merged>
  );
}

interface PalmProps {
  position: [number, number, number];
  rotation?: [number, number, number];
  scale?: number;
}

function Palm({ position, rotation = [0, 0, 0], scale = 1 }: PalmProps) {
  const instances = useContext(PalmInstancesContext);

  if (!instances) {
    console.error("Palm must be used within an <Instances> component.");
    return null;
  }

  return (
    <group position={position} rotation={rotation} scale={scale}>
      <instances.Palmhigh castShadow receiveShadow />
      <instances.Palmhigh1 castShadow receiveShadow />
    </group>
  );
}

function PalmLargeContent(props: ThreeElements["group"]) {
  // Flatten all palm positions into a single array
  const palmPositions = useMemo(() => {
    const results: PalmPosition[] = [];
    Object.values(PALM_POSITIONS).forEach((group) => {
      group.forEach(({ position, rotation = [0, 0, 0], scale = 1 }) => {
        results.push({ position, rotation, scale });
      });
    });
    return results;
  }, []);

  return (
    <group {...props} dispose={null}>
      {palmPositions.map((palmProps, index) => (
        <Palm key={index} {...palmProps} />
      ))}
    </group>
  );
}

export function PalmLarge(props: ThreeElements["group"]) {
  // Force shadow update on mount
  useEffect(() => {
    // Force a render update to ensure shadows are applied
    const timeout = setTimeout(() => {
      const event = new CustomEvent('shadow-update');
      window.dispatchEvent(event);
    }, 100);
    
    return () => clearTimeout(timeout);
  }, []);
  
  return (
    <Instances>
      <PalmLargeContent {...props} />
    </Instances>
  );
}

// Preload the GLTF so it's ready when <PalmLarge> mounts
useGLTF.preload("/models/tree-large.glb");
