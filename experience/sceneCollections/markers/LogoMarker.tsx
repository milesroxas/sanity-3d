/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import React, { useRef, useEffect } from 'react'
import { useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { ThreeElements, useFrame } from '@react-three/fiber'
type GLTFResult = GLTF & {
  nodes: {
    Mesh007: THREE.Mesh
    Mesh007_1: THREE.Mesh
    Mesh007_2: THREE.Mesh
    leaf: THREE.Mesh
  }
  materials: {
    ['Material.003']: THREE.MeshStandardMaterial
    ['Material.004']: THREE.MeshStandardMaterial
    Material: THREE.MeshStandardMaterial
  }
}

type LogoMarkerProps = ThreeElements['group'] & {
  isHovered?: boolean;
  scale?: number | [number, number, number];
}

export function LogoMarker(props: LogoMarkerProps) {
  const { nodes, materials } = useGLTF('/models/logoMarker.glb') as GLTFResult
  const { isHovered = false, scale = 1, ...groupProps } = props;
  const groupRef = useRef<THREE.Group>(null);
  const animationRef = useRef<number | null>(null);
  
  // Simplified animation approach - just apply rotation and position directly
  useEffect(() => {
    if (!groupRef.current) return;
    
    // Cancel any ongoing animation
    if (animationRef.current !== null) {
      cancelAnimationFrame(animationRef.current);
      animationRef.current = null;
    }
    
    // Set up the transition
    const duration = 600; // Increased from 300ms to 800ms for a slower, more deliberate animation
    const startTime = Date.now();
    const startRotation = groupRef.current.rotation.y || 0;
    const startPosition = groupRef.current.position.y || 0;
    
    // Get current scale
    const currentScale = groupRef.current.scale.x;
    const baseScale = typeof scale === 'number' ? scale : scale[0];
    
    // Target values
    const targetRotation = isHovered ? Math.PI * 2 : 0;
    const targetPosition = isHovered ? 0.5 : 0;
    const targetScale = isHovered ? baseScale * 1.2 : baseScale;
    
    // Animation function
    const animate = () => {
      if (!groupRef.current) return;
      
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // Ease in-out function
      const easeInOut = (t: number) => 
        t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
      
      const easedProgress = easeInOut(progress);
      
      // Apply interpolated values
      groupRef.current.rotation.y = startRotation + (targetRotation - startRotation) * easedProgress;
      groupRef.current.position.y = startPosition + (targetPosition - startPosition) * easedProgress;
      
      // Apply scale animation
      const newScale = currentScale + (targetScale - currentScale) * easedProgress;
      groupRef.current.scale.set(newScale, newScale, newScale);
      
      // Continue animation if not complete
      if (progress < 1) {
        animationRef.current = requestAnimationFrame(animate);
      } else {
        // Reset rotation to 0 when complete if we were hovering out
        // This prevents accumulating rotations
        if (!isHovered && groupRef.current) {
          groupRef.current.rotation.y = 0;
        }
        animationRef.current = null;
      }
    };
    
    // Start animation
    animationRef.current = requestAnimationFrame(animate);
    
    // Cleanup animation on unmount or when props change
    return () => {
      if (animationRef.current !== null) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = null;
      }
    };
  }, [isHovered, scale]);
  
  return (
    <group ref={groupRef} {...groupProps} dispose={null}>
      <group name="Scene" position={[0, 1, 0]}>
        <group name="logo" position={[0, 6.656, 0]} rotation={[Math.PI / 2, 0, 0]} scale={0.227}>
          <mesh
            name="Mesh007"
            castShadow
            receiveShadow
            geometry={nodes.Mesh007.geometry}
            material={materials['Material.003']}
          />
          <mesh
            name="Mesh007_1"
            castShadow
            receiveShadow
            geometry={nodes.Mesh007_1.geometry}
            material={materials['Material.004']}
          />
          <mesh
            name="Mesh007_2"
            castShadow
            receiveShadow
            geometry={nodes.Mesh007_2.geometry}
            material={materials['Material.004']}
          />
        </group>
        <mesh
          name="leaf"
          castShadow
          receiveShadow
          geometry={nodes.leaf.geometry}
          material={materials.Material}
          position={[0, 4.4, 0.817]}
          rotation={[Math.PI / 2, 0, 0]}
          scale={1.228}
        />
      </group>
    </group>
  )
}

useGLTF.preload('/models/logoMarker.glb')
