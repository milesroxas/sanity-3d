/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import React, { useRef, useEffect } from 'react'
import { useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { ThreeElements } from '@react-three/fiber'
import gsap from 'gsap'

type GLTFResult = GLTF & {
  nodes: {
    Mesh006: THREE.Mesh
    Mesh006_1: THREE.Mesh
    Mesh006_2: THREE.Mesh
  }
  materials: {
    ['Logo.001']: THREE.MeshStandardMaterial
    ['Material.002']: THREE.MeshStandardMaterial
    ['Material.004']: THREE.MeshStandardMaterial
  }
}

type LogoMarkerProps = ThreeElements['group'] & {
  isHovered?: boolean;
  scale?: number | [number, number, number];
  opacity?: number;
}

export function LogoMarker(props: LogoMarkerProps) {
  const { nodes, materials } = useGLTF('/models/logoMarker.glb') as GLTFResult
  const { isHovered = false, scale = 1, opacity = 1, ...groupProps } = props;
  const groupRef = useRef<THREE.Group>(null);
  const opacityRef = useRef(opacity);
  const previousOpacityRef = useRef(opacity);
  const isFadingIn = previousOpacityRef.current === 0 && opacity > 0;
  const isFadingOut = previousOpacityRef.current > 0 && opacity === 0;
  
  // GSAP animation setup for both opacity and transform animations
  useEffect(() => {
    if (!groupRef.current) return;
    
    const baseScale = typeof scale === 'number' ? scale : scale[0];
    const targetScale = isHovered ? baseScale * 1.2 : baseScale;
    
    // Create GSAP timeline for coordinated animations
    const tl = gsap.timeline({
      defaults: { duration: 0.6, ease: "power2.inOut" }
    });
    
    // Handle opacity changes
    tl.to(opacityRef, {
      current: opacity,
      duration: 0.6,
      onUpdate: () => {
        if (!materials) return;
        Object.values(materials).forEach(material => {
          material.opacity = opacityRef.current;
          material.transparent = opacityRef.current < 1;
          material.depthWrite = opacityRef.current >= 1;
          material.blending = opacityRef.current < 1 ? THREE.NormalBlending : THREE.NoBlending;
        });
      }
    });

    // If we're fading in, force reset to default state
    if (isFadingIn) {
      // Reset to default state first
      tl.to(groupRef.current.rotation, {
        y: 0,
        duration: 0.6
      }, ">")
      .to(groupRef.current.position, {
        y: 0,
        duration: 0.6
      }, "<")
      .to(groupRef.current.scale, {
        x: baseScale,
        y: baseScale,
        z: baseScale,
        duration: 0.6
      }, "<");
    }

    // If we're fading out, reset to default state before fading
    if (isFadingOut) {
      tl.to(groupRef.current.rotation, {
        y: 0,
        duration: 0.6
      }, "<")
      .to(groupRef.current.position, {
        y: 0,
        duration: 0.6
      }, "<")
      .to(groupRef.current.scale, {
        x: baseScale,
        y: baseScale,
        z: baseScale,
        duration: 0.6
      }, "<");
    }

    // Handle hover state changes only if we're not fading in or out
    if (opacity > 0 && !isFadingIn && !isFadingOut) {
      tl.to(groupRef.current.rotation, {
        y: isHovered ? Math.PI * 2 : 0,
        duration: 0.6
      }, "<")
      .to(groupRef.current.position, {
        y: isHovered ? 0.5 : 0,
        duration: 0.6
      }, "<")
      .to(groupRef.current.scale, {
        x: targetScale,
        y: targetScale,
        z: targetScale,
        duration: 0.6
      }, "<");
    }
    
    // Update previous opacity for next animation
    previousOpacityRef.current = opacity;
    
    // Cleanup
    return () => {
      tl.kill();
    };
  }, [isHovered, scale, opacity, materials, isFadingIn, isFadingOut]);

  // Reset state when component unmounts
  useEffect(() => {
    return () => {
      if (groupRef.current) {
        groupRef.current.rotation.y = 0;
        groupRef.current.position.y = 0;
        const baseScale = typeof scale === 'number' ? scale : scale[0];
        groupRef.current.scale.set(baseScale, baseScale, baseScale);
      }
    };
  }, [scale]);
  
  return (
    <group ref={groupRef} {...groupProps} dispose={null}>
      <group position={[0, 5.185, 0]} rotation={[Math.PI / 2, 0, 0]} scale={[0.279, 0.088, 0.279]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Mesh006.geometry}
          material={materials['Logo.001']}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Mesh006_1.geometry}
          material={materials['Material.002']}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Mesh006_2.geometry}
          material={materials['Material.004']}
        />
      </group>
    </group>
  )
}

useGLTF.preload('/models/logoMarker.glb')
