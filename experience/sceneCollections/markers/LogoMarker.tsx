/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import React, { useRef, useEffect } from 'react'
import { useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { ThreeElements, useFrame } from '@react-three/fiber'

type GLTFResult = GLTF & {
  nodes: {
    Mesh006: THREE.Mesh
    Mesh006_1: THREE.Mesh
    Mesh006_2: THREE.Mesh
  }
  materials: {
    ['Logo.001']: THREE.MeshStandardMaterial
    ['Material.002']: THREE.MeshStandardMaterial
    ['Material.004']: THREE.MeshStandardMaterial
  }
}

type LogoMarkerProps = ThreeElements['group'] & {
  isHovered?: boolean;
  scale?: number | [number, number, number];
  opacity?: number;
}

export function LogoMarker(props: LogoMarkerProps) {
  const { nodes, materials } = useGLTF('/models/logoMarker.glb') as GLTFResult
  const { isHovered = false, scale = 1, opacity = 1, ...groupProps } = props;
  const groupRef = useRef<THREE.Group>(null);
  const animationRef = useRef<number | null>(null);
  
  // Apply opacity to all materials
  useEffect(() => {
    if (!materials) return;
    
    // Store original opacity values if not already stored
    if (!materials['Logo.001'].userData.originalOpacity) {
      materials['Logo.001'].userData.originalOpacity = materials['Logo.001'].opacity;
      materials['Material.002'].userData.originalOpacity = materials['Material.002'].opacity;
      materials['Material.004'].userData.originalOpacity = materials['Material.004'].opacity;
    }
    
    // Animate the opacity change
    const duration = 500; // 500ms transition
    const startTime = Date.now();
    const startOpacities = {
      logo001: materials['Logo.001'].opacity,
      material002: materials['Material.002'].opacity,
      material004: materials['Material.004'].opacity
    };
    
    // Always set transparent when we want to animate opacity
    materials['Logo.001'].transparent = true;
    materials['Material.002'].transparent = true;
    materials['Material.004'].transparent = true;
    
    const animateOpacity = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // Ease out cubic function for smooth transition
      const easeOut = (t: number) => 1 - Math.pow(1 - t, 3);
      const easedProgress = easeOut(progress);
      
      // Interpolate opacity values
      materials['Logo.001'].opacity = startOpacities.logo001 + (opacity - startOpacities.logo001) * easedProgress;
      materials['Material.002'].opacity = startOpacities.material002 + (opacity - startOpacities.material002) * easedProgress;
      materials['Material.004'].opacity = startOpacities.material004 + (opacity - startOpacities.material004) * easedProgress;
      
      if (progress < 1) {
        requestAnimationFrame(animateOpacity);
      } else {
        // Final opacity set
        materials['Logo.001'].opacity = opacity;
        materials['Material.002'].opacity = opacity;
        materials['Material.004'].opacity = opacity;
        
        // Set transparent property based on final opacity
        materials['Logo.001'].transparent = opacity < 1;
        materials['Material.002'].transparent = opacity < 1;
        materials['Material.004'].transparent = opacity < 1;
      }
    };
    
    // Start animation
    requestAnimationFrame(animateOpacity);
    
    return () => {
      // No specific cleanup needed since we're not creating new materials
    };
  }, [materials, opacity]);
  
  // Simplified animation approach - just apply rotation and position directly
  useEffect(() => {
    if (!groupRef.current) return;
    
    // Cancel any ongoing animation
    if (animationRef.current !== null) {
      cancelAnimationFrame(animationRef.current);
      animationRef.current = null;
    }
    
    // Set up the transition
    const duration = 600; // Increased from 300ms to 800ms for a slower, more deliberate animation
    const startTime = Date.now();
    const startRotation = groupRef.current.rotation.y || 0;
    const startPosition = groupRef.current.position.y || 0;
    
    // Get current scale
    const currentScale = groupRef.current.scale.x;
    const baseScale = typeof scale === 'number' ? scale : scale[0];
    
    // Target values
    const targetRotation = isHovered ? Math.PI * 2 : 0;
    const targetPosition = isHovered ? 0.5 : 0;
    const targetScale = isHovered ? baseScale * 1.2 : baseScale;
    
    // Animation function
    const animate = () => {
      if (!groupRef.current) return;
      
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // Ease in-out function
      const easeInOut = (t: number) => 
        t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
      
      const easedProgress = easeInOut(progress);
      
      // Apply interpolated values
      groupRef.current.rotation.y = startRotation + (targetRotation - startRotation) * easedProgress;
      groupRef.current.position.y = startPosition + (targetPosition - startPosition) * easedProgress;
      
      // Apply scale animation
      const newScale = currentScale + (targetScale - currentScale) * easedProgress;
      groupRef.current.scale.set(newScale, newScale, newScale);
      
      // Continue animation if not complete
      if (progress < 1) {
        animationRef.current = requestAnimationFrame(animate);
      } else {
        // Reset rotation to 0 when complete if we were hovering out
        // This prevents accumulating rotations
        if (!isHovered && groupRef.current) {
          groupRef.current.rotation.y = 0;
        }
        animationRef.current = null;
      }
    };
    
    // Start animation
    animationRef.current = requestAnimationFrame(animate);
    
    // Cleanup animation on unmount or when props change
    return () => {
      if (animationRef.current !== null) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = null;
      }
    };
  }, [isHovered, scale]);
  
  return (
    <group ref={groupRef} {...groupProps} dispose={null}>
      <group position={[0, 5.185, 0]} rotation={[Math.PI / 2, 0, 0]} scale={[0.279, 0.088, 0.279]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Mesh006.geometry}
          material={materials['Logo.001']}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Mesh006_1.geometry}
          material={materials['Material.002']}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Mesh006_2.geometry}
          material={materials['Material.004']}
        />
      </group>
    </group>
  )
}

useGLTF.preload('/models/logoMarker.glb')
