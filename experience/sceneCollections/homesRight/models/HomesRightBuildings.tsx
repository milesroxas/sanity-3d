/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useMemo, useContext, createContext } from "react";
import type { ReactNode, ReactElement } from "react";
import { useGLTF, Merged } from "@react-three/drei";
import type * as THREE from "three";
import type { GLTF } from "three-stdlib";
import type { ThreeElements } from "@react-three/fiber";

/** The shape of your GLTF model */
type GLTFResult = GLTF & {
  nodes: {
    ["building-house-modern001_1"]: THREE.Mesh;
    ["building-house-modern001_2"]: THREE.Mesh;
    ["building-house-modern001_3"]: THREE.Mesh;
    ["building-house-modern001_4"]: THREE.Mesh;
    ["building-house-modern001_5"]: THREE.Mesh;
    ["building-house-modern001_6"]: THREE.Mesh;
  };
  materials: {
    ["12 BROWN"]: THREE.MeshPhysicalMaterial;
    ["18 GREY-DARK.002"]: THREE.MeshPhysicalMaterial;
    ["58 WHITE"]: THREE.MeshPhysicalMaterial;
    ["20 GREY"]: THREE.MeshPhysicalMaterial;
    ["64 GLASS"]: THREE.MeshPhysicalMaterial;
    ["17 GREY-DARKEST.002"]: THREE.MeshPhysicalMaterial;
  };
};

/** The final props we pass to <Building> need a 3D [x,y,z] plus rotation/scale. */
interface BuildingProps {
  position: [number, number, number];
  rotation?: [number, number, number];
  scale?: number;
}

/**
 * When `Merged` processes your meshes, it provides small React
 * components you can render – not raw THREE.Mesh objects.
 */
interface BuildingInstances {
  Buildinghousemodern: (props?: ThreeElements["mesh"]) => ReactElement;
  Buildinghousemodern1: (props?: ThreeElements["mesh"]) => ReactElement;
  Buildinghousemodern2: (props?: ThreeElements["mesh"]) => ReactElement;
  Buildinghousemodern3: (props?: ThreeElements["mesh"]) => ReactElement;
  Buildinghousemodern4: (props?: ThreeElements["mesh"]) => ReactElement;
  Buildinghousemodern5: (props?: ThreeElements["mesh"]) => ReactElement;
}

const BuildingInstancesContext = createContext<BuildingInstances | null>(null);

/** Define building patterns by name */
const BUILDING_POSITIONS = {
  eastFacing: [
    { position: [165.404, -16.109] },
    { position: [165.404, 3.07] },
    { position: [165.404, 21.656] },
  ],
  westFacing: [
    { position: [133.355, -29.551] },
    { position: [133.355, -10.965] },
    { position: [133.355, 8.214] },
  ],
  northFacing: [{ position: [135.856, 27.054] }],
} as const;

interface InstancesProps {
  children: ReactNode;
  /** Any other group props you might want */
  [key: string]: unknown;
}

/**
 * Instances sets up <Merged> so that multiple buildings share the
 * same geometry/material, improving performance.
 */
export function Instances({ children, ...props }: InstancesProps) {
  const { nodes } = useGLTF("/models/homes-right-buildings.glb") as GLTFResult;

  const instanceMeshes = useMemo(
    () => ({
      Buildinghousemodern: nodes["building-house-modern001_1"],
      Buildinghousemodern1: nodes["building-house-modern001_2"],
      Buildinghousemodern2: nodes["building-house-modern001_3"],
      Buildinghousemodern3: nodes["building-house-modern001_4"],
      Buildinghousemodern4: nodes["building-house-modern001_5"],
      Buildinghousemodern5: nodes["building-house-modern001_6"],
    }),
    [nodes]
  );

  return (
    <Merged meshes={instanceMeshes} {...props}>
      {(merged: BuildingInstances) => (
        <BuildingInstancesContext.Provider value={merged}>
          {children}
        </BuildingInstancesContext.Provider>
      )}
    </Merged>
  );
}

/** A single building, which re-uses geometry from context. */
function Building({
  position,
  rotation = [0, 0, 0],
  scale = 1,
}: BuildingProps) {
  const instances = useContext(BuildingInstancesContext);

  if (!instances) {
    console.error("Building must be used within an <Instances> component");
    return null;
  }

  return (
    <group position={position} rotation={rotation} scale={scale}>
      <instances.Buildinghousemodern name="building-house-modern001_1" />
      <instances.Buildinghousemodern1 name="building-house-modern001_2" />
      <instances.Buildinghousemodern2 name="building-house-modern001_3" />
      <instances.Buildinghousemodern3 name="building-house-modern001_4" />
      <instances.Buildinghousemodern4 name="building-house-modern001_5" />
      <instances.Buildinghousemodern5 name="building-house-modern001_6" />
    </group>
  );
}

function HomesRightBuildingsContent(props: ThreeElements["group"]) {
  // Convert 2D positions into final BuildingProps (with y=2.667, plus rotation).
  const buildingPositions = useMemo(() => {
    const results: BuildingProps[] = [];

    // East-facing buildings (rotate -π/2)
    BUILDING_POSITIONS.eastFacing.forEach(({ position: [x, z] }) => {
      results.push({
        position: [x, 2.667, z],
        rotation: [0, -Math.PI / 2, 0],
      });
    });

    // West-facing buildings (rotate +π/2)
    BUILDING_POSITIONS.westFacing.forEach(({ position: [x, z] }) => {
      results.push({
        position: [x, 2.667, z],
        rotation: [0, Math.PI / 2, 0],
      });
    });

    // North-facing buildings (rotation = 0)
    BUILDING_POSITIONS.northFacing.forEach(({ position: [x, z] }) => {
      results.push({
        position: [x, 2.667, z],
        rotation: [0, 0, 0],
      });
    });

    return results;
  }, []);

  return (
    <group {...props} dispose={null}>
      {buildingPositions.map((buildingProps, index) => (
        <Building key={index} {...buildingProps} />
      ))}
    </group>
  );
}

export function HomesRightBuildings(props: ThreeElements["group"]) {
  return (
    <Instances>
      <HomesRightBuildingsContent {...props} />
    </Instances>
  );
}

// Preload the GLTF so it’s cached before <HomesRightBuildings> mounts
useGLTF.preload("/models/homes-right-buildings.glb");
