/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { MeshGLTFModel } from '@/experience/types/modelTypes';
import { createSharedAtlasMaterial } from '@/experience/utils/materialUtils';
import { useGLTF, useTexture } from '@react-three/drei';
import { ThreeElements, useFrame } from '@react-three/fiber';
import { useEffect, useMemo, useRef } from 'react';
import * as THREE from 'three';

export function IntroGrass(props: ThreeElements['group']) {
  const { nodes, materials } = useGLTF(
    '/models/landing/intro-grass.glb'
  ) as unknown as MeshGLTFModel;

  // Load textures separately with useTexture
  const { specularMap, emissionMap } = useTexture({
    specularMap: '/textures/color-atlas-specular.png',
    emissionMap: '/textures/color-atlas-emission-night.png',
  });

  // Create material with non-reflective properties
  const LowpolyMaterial = useMemo(
    () =>
      createSharedAtlasMaterial(materials, {
        roughness: 1,
        metalness: 0,
        envMapIntensity: 0,
      }),
    [materials]
  );

  // Material ref to track if properties are being overridden
  const materialRef = useRef(LowpolyMaterial);

  // Track if component is mounted to prevent memory leaks
  const isMounted = useRef(true);

  // Apply textures after they're loaded
  useEffect(() => {
    if (materialRef.current) {
      const gridSize = 2;
      specularMap.wrapS = specularMap.wrapT = THREE.RepeatWrapping;
      specularMap.repeat.set(1 / gridSize, 1 / gridSize);
      specularMap.offset.set(5 / gridSize, 1 - (1 + 1) / gridSize);
      materialRef.current.roughnessMap = specularMap;

      // Explicitly set these properties again to ensure they're not overridden
      materialRef.current.roughness = 1;
      materialRef.current.metalness = 0;
      materialRef.current.envMapIntensity = 0;

      materialRef.current.needsUpdate = true;
    }

    if (emissionMap && materialRef.current) {
      const gridSize = 8;
      emissionMap.wrapS = emissionMap.wrapT = THREE.RepeatWrapping;
      emissionMap.repeat.set(1 / gridSize, 1 / gridSize);
      emissionMap.offset.set(5 / gridSize, 1 - (1 + 1) / gridSize);
      materialRef.current.emissiveMap = emissionMap;
    }

    // Cleanup function to handle disposal
    return () => {
      isMounted.current = false;

      // Don't dispose shared material as it might be used elsewhere
      // But we can clean up our own references and maps if needed
      if (materialRef.current) {
        // Only dispose maps we explicitly added (not the base material)
        if (materialRef.current.roughnessMap === specularMap) {
          materialRef.current.roughnessMap = null;
        }
        if (materialRef.current.emissiveMap === emissionMap) {
          materialRef.current.emissiveMap = null;
        }

        materialRef.current.needsUpdate = true;
      }
    };
  }, [materialRef.current, specularMap, emissionMap]);

  // Use useFrame to constantly enforce non-reflective properties
  // This ensures the material stays non-reflective even when environment changes
  useFrame(() => {
    if (materialRef.current && isMounted.current) {
      materialRef.current.envMapIntensity = 0;
      materialRef.current.roughness = 1;
      materialRef.current.metalness = 0;
    }
  });

  return (
    <group {...props} dispose={null}>
      <group name="Scene004">
        <group {...props} dispose={null}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes['landing-grass'].geometry}
            material={materialRef.current}
            position={[-65.126, 2.71, -147.794]}
          />
        </group>
      </group>
    </group>
  );
}

useGLTF.preload('/models/landing/intro-grass.glb');
